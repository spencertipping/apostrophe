# Linux/x86-64 bytecode dynamic compiler | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Introduction.
# This compiler translates Apostrophe core-level bytecode into machine instructions and gives you a way to execute them. It is implemented as a concatentative language over %rsp. The mapping
# from (debatably) human-readable ASCII bytecode to instructions is achieved by using code in a lookup table referenced by %rbp. This mapping encodes SDoc syntax by redirecting all capital
# letters to functions which detect two newlines. All input is read from file descriptor 0 (stdin).

# This interpreter is written in flat-style; that is, no function calls unless absolutely necessary. Some people would consider this to be "spaghetti code"; I wouldn't blame them for this
# interpretation.

.section .rodata
  mmap_error:      .ascii "error: could not allocate memory (mmap failed)\n"
  mmap_error_size: .quad mmap_error_size - mmap_error

  start_sdoc_capitals: .byte 'A'
  end_sdoc_capitals:   .byte 'Z'
  sdoc_pipe:           .byte '|'
  comment_hash:        .byte '#'
  newline:             .byte '\n'

.text
  .globl _start
  .type _start, @function

  _start:
  jmp setup_dispatch_table
  setup_dispatch_table_cc:
  jmp setup_stdin_buffer
  setup_stdin_buffer_cc:

  # main function goes here (sentinel for now)
  movq $141, %rdi
  jmp exit

  exit:
  movq $60, %rax
  syscall

  stderr:                                       # buf = %rsi, length = %rdx, continuation = %r12 -> result = %rax
  pushq %rdi
  movq $1, %rax                                 # syscall = write
  movq $2, %rdi                                 # fd      = 2 (stderr)
  syscall
  popq %rdi
  jmp *%r12

  allocate:                                     # size = %rsi, continuation = %r12 -> result = %rax
  pushq %rdi
  pushq %rdx
  pushq %rcx
  pushq %r8
  pushq %r9
  movq $9, %rax                                 # syscall = mmap
  xorq %rdi, %rdi                               # *addr   = NULL
  movq $3, %rdx                                 # prot    = PROT_READ | PROT_WRITE
  movq $0x22, %rcx                              # flags   = MAP_PRIVATE | MAP_ANONYMOUS
  movq $-1, %r8                                 # fd      = -1
  xorq %r9, %r9                                 # offset  = 0
  syscall
  popq %r9
  popq %r8
  popq %rcx
  popq %rdx

  testq %rax, %rax                              # negative return values from mmap() indicate failure
  jns allocate_ok

  movq $mmap_error, %rsi
  movq mmap_error_size, %rdx
  negq %rax                                     # use errno as program return code
  movq %rax, %rdi
  movq $exit, %r12
  jmp stderr

  allocate_ok:
  popq %rdi
  jmp *%r12

# Dispatch table setup.
# The initial dispatch table is dynamically allocated using mmap and initialized from assembly code. Letters from A-Z and | are set up to consume input until a \n\n is reached. This allows you
# to write SDoc into the bytecode. The dispatch table is addressed using %rbp and is scaled by 8 bytes (2048 bytes per table).

  setup_dispatch_table:
  movq $4096, %rsi
  movq $setup_dispatch_table_mmap_ok, %r12
  jmp allocate

  setup_dispatch_table_mmap_ok:
  movq %rax, %rbp
  movq start_sdoc_capitals, %rcx

  # Writing dispatch instructions.
#   The dispatch table contains a bunch of jump offsets to functions defined here in assembly code.

    setup_dispatch_table_capital_letter_loop:
    movq $read_sdoc_paragraph, (,%rcx,8)

    incq %rcx
    testq end_sdoc_capitals, %rcx
    jne setup_dispatch_table_capital_letter_loop

  jmp setup_dispatch_table_cc

# Standard input reader.
# There are two steps here. First, allocate a buffer using mmap; second, read stuff into that buffer using the read syscall.

  setup_stdin_buffer:
  movq $4096, %rsi
  movq $setup_stdin_buffer_ok, %r12
  jmp allocate

  setup_stdin_buffer_ok:
  jmp setup_stdin_buffer_cc

# SDoc reader.
# Munch stuff, storing state by jumping instead of by using registers.

  read_sdoc_paragraph:
  movq $3, %rdi
  jmp exit

# Generated by SDoc 
